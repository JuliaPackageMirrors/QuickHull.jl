{
    "docs": [
        {
            "location": "/", 
            "text": "The QuickHull package\n\n\nQuickHull is a na\u00efve implementation of the \nQuickHull\n algorithm for calculating the convex hull of a set of points in 2D.\n\n\n\n\n\n\nUsage\n\n\nThe algorithm works with \nVec{2}\ns from \nFixedSizeArrays\n, so you can pass a vector of such points directly to the algorithm:\n\n\nusing FixedSizeArrays\npoints = map(Vec, rand(25), rand(25))\n\nusing QuickHull\nhull = qhull(points)\n\n\n\n\n7-element Array{FixedSizeArrays.Vec{2,Float64},1}:\n Vec(0.0899343,0.622854)\n Vec(0.129351,0.106585)\n Vec(0.623142,0.0427077)\n Vec(0.929395,0.010332)\n Vec(0.898733,0.807575)\n Vec(0.662745,0.98774)\n Vec(0.0982147,0.923074)\n\n\n\n\nThe points are returned in order, starting with the leftmost point and moving counter-clockwise around convex hull.\n\n\nYou can also just pass two arrays of equal length containing the $x$ and $y$ values of your points, and \nqhull\n will figure it out:\n\n\nxs, ys = rand(25), rand(25)\n\nusing QuickHull\nxhull, yhull = qhull(xs, ys)\n\n\n\n\n([0.0231322,0.623347,0.696941,0.879159,0.877386,0.36626,0.173616],[0.353554,0.121724,0.159902,0.948169,0.999955,0.999282,0.896131])\n\n\n\n\nAs you notice, the format of the return values matches that of the input.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-quickhull-package", 
            "text": "QuickHull is a na\u00efve implementation of the  QuickHull  algorithm for calculating the convex hull of a set of points in 2D.", 
            "title": "The QuickHull package"
        }, 
        {
            "location": "/#usage", 
            "text": "The algorithm works with  Vec{2} s from  FixedSizeArrays , so you can pass a vector of such points directly to the algorithm:  using FixedSizeArrays\npoints = map(Vec, rand(25), rand(25))\n\nusing QuickHull\nhull = qhull(points)  7-element Array{FixedSizeArrays.Vec{2,Float64},1}:\n Vec(0.0899343,0.622854)\n Vec(0.129351,0.106585)\n Vec(0.623142,0.0427077)\n Vec(0.929395,0.010332)\n Vec(0.898733,0.807575)\n Vec(0.662745,0.98774)\n Vec(0.0982147,0.923074)  The points are returned in order, starting with the leftmost point and moving counter-clockwise around convex hull.  You can also just pass two arrays of equal length containing the $x$ and $y$ values of your points, and  qhull  will figure it out:  xs, ys = rand(25), rand(25)\n\nusing QuickHull\nxhull, yhull = qhull(xs, ys)  ([0.0231322,0.623347,0.696941,0.879159,0.877386,0.36626,0.173616],[0.353554,0.121724,0.159902,0.948169,0.999955,0.999282,0.896131])  As you notice, the format of the return values matches that of the input.", 
            "title": "Usage"
        }, 
        {
            "location": "/performance/", 
            "text": "Performance\n\n\nThe current implementation is not optimized at all, but still performs quite well on small enough data sets.\n\n\nUsing \nBenchmarkTools\n we can find out just how well:\n\n\njulia\n using BenchmarkTools, QuickHull\n\njulia\n points = map(Vec, rand(25), rand(25));\n\njulia\n @benchmark qhull(points)\nBenchmarkTools.Trial: \n  samples:          10000\n  evals/sample:     9\n  time tolerance:   5.00%\n  memory tolerance: 1.00%\n  memory estimate:  5.61 kb\n  allocs estimate:  66\n  minimum time:     2.15 \u03bcs (0.00% GC)\n  median time:      2.47 \u03bcs (0.00% GC)\n  mean time:        3.86 \u03bcs (31.64% GC)\n  maximum time:     638.79 \u03bcs (98.87% GC)\n\n\n\n\nThe data set here is quite small, but it needs to be for the hull to have a shape that is more interesting than the square $[1,2]^2$. We can increase the data set size to convince ourselves that the library still performs quite well. To avoid different runs interfering with each-other, we run \ngc()\n before each time:\n\n\njulia\n points2 = map(Vec, rand(1_000_000), rand(1_000_000));\n\njulia\n gc(); @time qhull(points2);\n  0.053300 seconds (407 allocations: 59.894 MB, 4.72% gc time)\n\njulia\n gc(); @time qhull(points2);\n  0.054250 seconds (407 allocations: 59.894 MB, 4.64% gc time)\n\n\n\n\nHowever, these tests are also pretty na\u00efve - for example, the points are all constrained to a small region with a simple shape, and so fit the algorithm extremely well.\n\n\nIf you have a use case where this library does not peform well enough, please do file an issue, and we can try to optimize it together.", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#performance", 
            "text": "The current implementation is not optimized at all, but still performs quite well on small enough data sets.  Using  BenchmarkTools  we can find out just how well:  julia  using BenchmarkTools, QuickHull\n\njulia  points = map(Vec, rand(25), rand(25));\n\njulia  @benchmark qhull(points)\nBenchmarkTools.Trial: \n  samples:          10000\n  evals/sample:     9\n  time tolerance:   5.00%\n  memory tolerance: 1.00%\n  memory estimate:  5.61 kb\n  allocs estimate:  66\n  minimum time:     2.15 \u03bcs (0.00% GC)\n  median time:      2.47 \u03bcs (0.00% GC)\n  mean time:        3.86 \u03bcs (31.64% GC)\n  maximum time:     638.79 \u03bcs (98.87% GC)  The data set here is quite small, but it needs to be for the hull to have a shape that is more interesting than the square $[1,2]^2$. We can increase the data set size to convince ourselves that the library still performs quite well. To avoid different runs interfering with each-other, we run  gc()  before each time:  julia  points2 = map(Vec, rand(1_000_000), rand(1_000_000));\n\njulia  gc(); @time qhull(points2);\n  0.053300 seconds (407 allocations: 59.894 MB, 4.72% gc time)\n\njulia  gc(); @time qhull(points2);\n  0.054250 seconds (407 allocations: 59.894 MB, 4.64% gc time)  However, these tests are also pretty na\u00efve - for example, the points are all constrained to a small region with a simple shape, and so fit the algorithm extremely well.  If you have a use case where this library does not peform well enough, please do file an issue, and we can try to optimize it together.", 
            "title": "Performance"
        }
    ]
}